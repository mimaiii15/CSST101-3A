# -*- coding: utf-8 -*-
"""3A_VARGAS_MP2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wbZAAX2trd1RX8t-dWfFqJcDXkEnnoJb

# **Propositional Logic Operations**
"""

def and_operation(p, q):
    """Logical conjunction (AND)."""
    return p and q

def or_operation(p, q):
    """Logical disjunction (OR)."""
    return p or q

def not_operation(p):
    """Logical negation (NOT)."""
    return not p

def implies_operation(p, q):
    """Logical implication (IMPLIES)."""
    return not p or q

"""# **Evaluate Logical Statements**"""

def evaluate(statement, values):
    """Evaluate a logical statement based on given truth values."""

    statement = statement.replace('AND', 'and').replace('OR', 'or').replace('NOT', 'not')
    statement = statement.replace('(', ' ( ').replace(')', ' ) ')

    tokens = statement.split()

    stack = []

    for token in tokens:
        if token in values:
            stack.append(values[token])
        elif token == 'not':
            stack.append(not stack.pop())
        elif token in ['and', 'or']:
            right = stack.pop()
            left = stack.pop()
            if token == 'and':
                stack.append(left and right)
            elif token == 'or':
                stack.append(left or right)
        else:
            raise ValueError(f"Unknown token: {token}")

    return stack[0] if stack else None

"""### **Example Usage**"""

def evaluate(statement, values):
    """Evaluate a logical statement based on given truth values."""

    statement = statement.replace('AND', ' and ').replace('OR', ' or ').replace('NOT', ' not ') # Add spaces around operators
    statement = statement.replace('(', '( ').replace(')', ' ) ')

    tokens = statement.split()

    stack = []

    for token in tokens:
        if token in values:
            stack.append(values[token])
        elif token == 'not':
            if stack: # Check if stack is not empty before popping
                stack.append(not stack.pop())
        elif token in ['and', 'or']:
            if len(stack) >= 2: # Check if there are enough operands
                right = stack.pop()
                left = stack.pop()
                if token == 'and':
                    stack.append(left and right)
                elif token == 'or':
                    stack.append(left or right)
        # Removed the else block as it was raising a ValueError for parentheses

    return stack[0] if stack else None

"""# **Predicate Logic with Quantifiers**

1. Universal Quantifier (∀)
The forall function checks if a given predicate holds true for all elements in a specified domain.
2. Existential Quantifier (∃)
The exists function checks if there is at least one element in the specified domain for which the predicate holds true.
Implementation
Here’s how you can implement these functions in Python:
"""

def forall(predicate, domain):
    """Evaluate the universal quantifier (FOR ALL)."""
    return all(predicate(x) for x in domain)

def exists(predicate, domain):
    """Evaluate the existential quantifier (EXISTS)."""
    return any(predicate(x) for x in domain)

"""### **Example Usage of Quantifiers**"""

# Define a predicate function
def is_even(x):
    """Predicate to check if a number is even."""
    return x % 2 == 0

def is_positive(x):
    """Predicate to check if a number is positive."""
    return x > 0

# Define a domain
domain = range(-5, 6)  # Numbers from -5 to 5

# Evaluate universal quantifier
all_even = forall(is_even, domain)  # Should return False
print(f"All numbers are even: {all_even}")

# Evaluate existential quantifier
any_even = exists(is_even, domain)  # Should return True
print(f"Any number is even: {any_even}")

# Evaluate universal quantifier for positive numbers
all_positive = forall(is_positive, domain)  # Should return False
print(f"All numbers are positive: {all_positive}")

# Evaluate existential quantifier for positive numbers
any_positive = exists(is_positive, domain)  # Should return True
print(f"Any number is positive: {any_positive}")

"""# **Conclusion**

The forall and exists functions allow you to evaluate predicate logic statements efficiently over a specified domain. You can define any predicate function that takes a single argument and returns a boolean value, enabling you to check various conditions across different sets of data. This setup provides a flexible way to work with predicate logic in Python.

# **AI Agent Development**

The scenario involves a basic game where the AI agent must choose the best move based on the current state of the game. We will implement logical decision-making functions that the AI agent will use to determine its actions.

## **Scenario Definition**

We will create a simple game where the AI agent has three possible moves:
* Move Left
* Move Right
* Stay Still

The decision of the AI agent will be based on the following environmental conditions:
* Obstacle on the Left: If there is an obstacle on the left, the agent cannot move left.
* Obstacle on the Right: If there is an obstacle on the right, the agent cannot move right.
* Safety: If the agent is at a safe position, it can choose to stay still.

## **Implementing the Decision Logic**

We will implement the decision logic using Python functions. The AI agent will evaluate the conditions and choose the best move based on the logic defined.
"""

class SimpleAIAgent:
    def __init__(self):
        pass

    def decide_move(self, obstacle_left, obstacle_right, safe):
        """
        Decide the best move based on the presence of obstacles and safety.

        Parameters:
        obstacle_left (bool): True if there is an obstacle on the left.
        obstacle_right (bool): True if there is an obstacle on the right.
        safe (bool): True if the agent is in a safe position.

        Returns:
        str: The chosen move.
        """
        if not obstacle_left and not obstacle_right:
            return "Move Left"  # Prefer moving left if both sides are clear
        elif not obstacle_right:
            return "Move Right"  # Move right if left is blocked
        elif not obstacle_left:
            return "Move Left"  # Move left if right is blocked
        elif safe:
            return "Stay Still"  # Stay still if both sides are blocked but safe
        else:
            return "No Move Possible"  # No valid move available

# Example usage
agent = SimpleAIAgent()

# Test scenarios
scenarios = [
    (False, False, True),  # No obstacles, safe
    (True, False, True),   # Obstacle on left, safe
    (False, True, True),   # Obstacle on right, safe
    (True, True, True),    # Obstacles on both sides, safe
    (True, True, False)    # Obstacles on both sides, not safe
]

# Display the outcomes
for i, (left, right, safe) in enumerate(scenarios):
    move = agent.decide_move(left, right, safe)
    print(f"Scenario {i + 1}: Obstacle Left = {left}, Obstacle Right = {right}, Safe = {safe} => Move: {move}")

"""# **Explanation**

The AI agent operates within a defined scenario where it must navigate potential obstacles while considering its safety. The decision-making process is governed by a set of logical conditions that evaluate the presence of obstacles on both sides and the agent's safety status.

Here’s a breakdown of how the agent makes its decisions:
*   **No Obstacles and Safe**: When both sides are clear of obstacles, the agent
prefers to move left. This choice is likely based on a predefined strategy to favor leftward movement when possible.
*   **Obstacle on Left**: If there is an obstacle on the left but the right side is clear, the agent will move right. This decision ensures that the agent can continue to progress without hitting an obstacle.
*   **Obstacle on Right**: Conversely, if there is an obstacle on the right and the left side is clear, the agent will move left. This ensures that the agent avoids obstacles while still making progress.
*   **Both Sides Blocked but Safe**: If both sides are blocked but the agent is in a safe position, it chooses to stay still. This decision prevents the agent from making a potentially dangerous move.
*   **Both Sides Blocked and Not Safe**: In the worst-case scenario, where both sides are blocked and the agent is not safe, it cannot make any move. This reflects a situation where the agent must wait for conditions to improve before taking action.

# **Conclusion**
The AI agent demonstrates a straightforward yet effective decision-making process based on logical evaluations of its environment. By systematically assessing the presence of obstacles and its safety, the agent can make informed choices that maximize its chances of progressing in the game while minimizing risks.

This simple model highlights the importance of logic in AI decision-making and serves as a foundation for more complex agents that could incorporate additional factors such as dynamic environments, multiple objectives, or learning from past experiences.
"""